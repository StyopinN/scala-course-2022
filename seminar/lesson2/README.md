
# Семинар 2: Java Microbenchmark Harness (JMH)

## Что такое JMH и с чем его едят

JMH - это инструмент Java для создания, запуска и анализа тестов на производительность отдельных функций и методов.

<a href="https://github.com/openjdk/jmh">Страничка проекта на github</a> (там можно найти примеры java)
<br>
<a href="https://github.com/sbt/sbt-jmh">Страничка SBT-плагина на github</a> (там можно найти примеры scala)

Поддерживаются разные метрики. Наиболее полезные режимы:
- среднее время выполнения метода после разогрева (AverageTime)
- обратный к нему: сколько раз отработает метод за указанное время? (Throughput)
- время одного "холодного" запуска (SingleShotTime)

Можно настраивать разделяемое состояние:
- одно для всех беенчмарков (Benchmark)
- по одному на каждую группу бенчмарков (Group)
- по одному на каждый тред (Thread)

## Установка и использование

Устанавливаем плагин для sbt:
1. Прописываем зависимость в plugins.sbt
2. Разрешаем плагин в build.sbt
3. Помечаем интересующий нас метод аннотацией @Benchmark
4. Запускаем в sbt-консоли: `jmh:run` или отдельный тест: `jmh:run package.class.function`

Все параметры: `jmh:run -help`

Например: `jmh:run ExampleBenchmarks -f 1 -i 1 -wi 5`

<a href="https://www.gaurgaurav.com/java/scala-benchmarking-jmh/">Пример есть в этой статье</a> 


## Задания:

0. **Ведущий**: ExampleBenchmarks (15 минут)
   <br>Вводный рассказ и демонстрация настроек на примере.
   

1. **Ученик 1**: AddElementBenchmarks (20 минут)
   <br>Сравниваем добавление элементов в начало и конец списка.
   <br>Варианты из лекции и библиотечные.
   <br>На первом запуске ловим StackOverflow на рекурсивном варианте для списка 10000.
   <br>Уменьшаем до 1000 и повторяем.
   <br>Делаем вывод, что добавление в начало - "бесплатная" операция (отличие на порядки).

2. **Ученик 2**: RecursionBenchmarks (15 минут)
   <br>Переполнения стека в рекурсиях и хвостовая рекурсия
   <br>Предлагается исправить рекурсивный вариант, чтобы он не выпадал в StackOverflow.
   <br>Проверяем, что он уже не падает на 10000.
   <br>Сравниваем на 1000. Получаем хуже производительность, но зато не падает. =)

3. **Ученик 3**: CreateListBenchmarks (20 минут)
   <br>Собираем список из N элементов.
   <br>Сравниваем добавление по одному в начало, в конец, конструктор списка, конструктор Range и RichInt.
   <br>Обращаем внимание, что List.apply хуже некоторых вариантов. Причина в том, что он написан в общем виде для IterableOnce.

4. **Ученик 4**: CountBenchmarks (10 минут)
   <br>Реализация функции count.
   <br>Сравниваем плохой и хороший варианты из лекции и библиотечный вариант.


<!---
3. Получение элемента по индексу в списке и в векторе (слайд 32)
4. убираем повторяющиеся элементы (с reverse - слайд 54, без reverse - слайд ???)

Возможно:
1. самописная сортировка и библиотечная
2. сравнение самописного topN из первого ДЗ и .sorted.take(N)
-->