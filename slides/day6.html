<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Cats и Circe</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Часть 6. Cats и Circe</h3>
					<p><small>Страничка курса: <a href="https://maxcom.github.io/scala-course-2022/">https://maxcom.github.io/scala-course-2022/</a></small>
				</section>

				<section>
					<h3>План</h3>
					<ol>
						<li>Cats</li>
						<li>Circe</li>
					</ol>
				</section>









				<section>
					<h3>Библиотека Cats</h3>
					<ul>
						<li class=fragment>Предоставляет абстракции функционального программирования</li>
						<li class=fragment>Является основой для экосистемы чистих типизированных библиотек</li>
					</ul>
					<p class=fragment><small>* Название является шутливым сокращением слова "категория"</small>
				</section>

				<section>
					<h3>Библиотека Cats</h3>
					<div><img src="cats.png"></div>
					<p>Абстрактные котики, функциональный подход и теория категорий
					<p class=fragment><small>Смешать, но не взбалтывать =)</small>
				</section>

				<section>
					<h3>Основные понятия</h3>
					<ul>
						<li>Полугруппа (Semigroup)</li>
						<li>Моноид</li>
						<li>Функтор</li>
						<li>??? (Semigroupal)</li>
						<li>Аппликатив</li>
						<li>Монада</li>
						<li>и др. страшные слова</li>
					</ul>
				</section>

				<section>
					<h2>Монады</h2>
					(и связанные с ними концепции)
					<p>Архитектурные строительные блоки, которые появляются в программах снова и снова.
					<p class=fragment><small>т.е. являются для ФП эквивалентом шаблонов проектирования ООП</small>
				</section>

				<section>
					<h2>Их преимущества над ООП</h2>
					<ul>
						<li>Формально <small>(а, значит, очень точно)</small> определены</li>
						<li>Являются максимально обобщёнными</li>
					</ul>
				</section>

				<section>
					<h2>Модули библиотеки Cats</h2>
					<p>некоторые из них находятся в собственных репозиториях
				</section>

				<section>
					<h2>cats-kernel, cats-core</h2>
					<ul>
						<li>набор type-классов
						<li>минимальный набор структур данных для их поддержки
						<li>экземпляры классов типов для этих структур данных и стандартных типов
					</ul>
				</section>

				<section>
					<h2>cats-laws, cats-testkit,<br>cats-testkit-scalatest</h2>
					<ul>
						<li>набор тестов для проверки собственных инстансов на соответствие законам</li>
						<li>поддерживается Specs2, ScalaTest, ScalaCheck и др.</li>
					</ul>
				</section>

				<section>
					<h2>cats-effect</h2>
					<ul>
						<li>библиотека для ассинхронных вычисления</li>
						<li>основной тип IO - очень похож на Future, но более строгий</li>
					</ul>
					<small>(рассмотрим подробнее на следующих лекциях)</small>
				</section>

				<section>
					Есть и другие, но нам пока хватит.
				</section>

				<section>
					<p>Полезные ссылки:
					<ul>
						<li>Website: <a href="https://typelevel.org/cats">https://typelevel.org/cats</a></li>
						<span class=fragment>
							<li>Type classes: <a href="https://typelevel.org/cats/typeclasses">https://typelevel.org/cats/typeclasses</a></li>
							<li>Data types: <a href="https://typelevel.org/cats/datatypes">https://typelevel.org/cats/datatypes</a></li>
						</span>
						<li class=fragment>Scala exercises: <a href="https://scala-exercises.org/cats">https://scala-exercises.org/cats</a></li>
						<li class=fragment>Scala with Cats: <a href="https://scalawithcats.com">https://scalawithcats.com</a></li>
						<li class=fragment>Другие проекты экосистемы:<br><a href="https://typelevel.org/cats/typelevelEcosystem">https://typelevel.org/cats/typelevelEcosystem</a></li>
					</ul>
				</section>








				<section>
					<p><img src="cats2.png">
					<p>Рассмотрим наиболее полезные классы
				</section>








				<section>
					<h2>Полугруппа</h2>
					<p>Определена операция
					<pre><code class="scala">trait Semigroup[A] {
  def combine(x: A, y: A): A
}</code></pre>
					<div class=fragment>
					<p>Должна удовлетворять закону ассоциативности
					<pre><code class="scala">combine(x, combine(y, z)) = combine(combine(x, y), z)</code></pre>
					</div>
				</section>

				<section>
					<h2>Пример</h2>
					<p>Тип Int и операция сложения
					<pre><code class="scala">import cats.Semigroup

implicit val intAdditionSemigroup = new Semigroup[Int] {
  def combine(x: Int, y: Int): Int = x + y
}</code></pre>
					<small>Поэтому часто операцию "combine" называют "сложением"</small>
				</section>

				<section>
					<p>cats предоставляет infix-синтаксис для полугруп
					<pre><code class="scala">import cats.implicits._

1 |+| 2</code></pre>
				</section>

				<section>
					<h2>Ещё примеры</h2>
				</section>

				<section>
					<ul>
						<li>Тип String и операция "склеивания"</li>
						<li class=fragment>Кортежи: пары, тройки и т.д.</li>
					</ul>
				</section>

				<section>
					<p>Тип Map и операция merge
					<pre><code class="scala">import cats.implicits._

val map1 = Map("hello" -> 1, "world" -> 1)
val map2 = Map("hello" -> 2, "cats"  -> 3)

Semigroup[Map[String, Int]].combine(map1, map2)
// res5: Map[String, Int] =
//   Map("hello" -> 3, "cats" -> 3, "world" -> 1)

map1 |+| map2
// res6: Map[String, Int] =
//   Map("hello" -> 3, "cats" -> 3, "world" -> 1)</code></pre>
					<p class=fragment>Аналогично для List и других коллекций
				</section>

				<section>
					<p>Не надо изобретать велосипед:
					<p>инстансы этих классов и многих других уже есть в Cats
				</section>










				<section>
					<h2>Моноид</h2>
					<p>Полугруппа с "нулём"
					<pre><code class="scala">trait Semigroup[A] {
  def combine(x: A, y: A): A
}

trait Monoid[A] extends Semigroup[A] {
  def empty: A
}</code></pre>
				</section>

				<section>
					<p>Также удовлетворяет закону ассоциативности
					<pre><code class="scala">combine(x, combine(y, z)) = combine(combine(x, y), z)</code></pre>
					<div class=fragment>
						<p>И дополнительно закон для "нуля":
						<pre><code class="scala">combine(x, empty) = combine(empty, x) = x</code></pre>
					</div>
				</section>

				<section>
					<p>Большинство полугрупп легко расширяются до моноида.
				</section>

				<section>
					<ul>
						<li>Целые числа (Int, Long), сложение и 0</li>
						<li class=fragment>Целые числа (Int, Long), умножение и 1</li>
						<li class=fragment>String, конкатенация и пустая строка <code class="scala">""</code></li>
						<li class=fragment>Коллекция, конкатенация и пустая коллекция того же типа:
							<ul style="list-style-type: none;">
								<li class=fragment>Map[A, B] и Map.empty[A, B]</li>
								<li class=fragment>List[A] и List.empty[A]</li>
								<li class=fragment>и др.</li>
							</ul>
						</li>
					</ul>
				</section>

				<section>
					<pre><code class="scala">import cats.Monoid

implicit val intAdditionMonoid: Monoid[Int] = new Monoid[Int] {
  def empty: Int = 0
  def combine(x: Int, y: Int): Int = x + y
}</code></pre>
				</section>

				<section>
					<pre><code class="scala">val x = 1

Monoid[Int].combine(x, Monoid[Int].empty)
// res1: Int = 1

Monoid[Int].combine(Monoid[Int].empty, x)
// res2: Int = 1</code></pre>
				</section>

				<section>
					<p>Cats предоставляет операции для коллекций над моноидами.
				</section>

				<section>
					<pre><code class="scala">def combineAll[A: Monoid](as: List[A]): A =
      as.foldLeft(Monoid[A].empty)(Monoid[A].combine)</code></pre>
				</section>

				<section>
					<pre><code class="scala">import cats.implicits._

combineAll(List(1, 2, 3))
// res: Int = 6</code></pre>
				</section>

				<section>
					<pre><code class="scala">import cats.implicits._

combineAll(List("hello", " ", "world"))
// res: String = "hello world"
</code></pre>
				</section>

				<section>
					<pre><code class="scala">import cats.implicits._

combineAll(List(
             Map('a' -> 1),
             Map('a' -> 2, 'b' -> 3),
             Map('b' -> 4, 'c' -> 5)
          ))
// res: Map[Char, Int] = Map('b' -> 7, 'c' -> 5, 'a' -> 3)</code></pre>
				</section>

				<section>
					<pre><code class="scala">import cats.implicits._

combineAll(List(
             Set(1, 2),
             Set(2, 3, 4, 5)
          ))
// res: Set[Int] = Set(5, 1, 2, 3, 4)</code></pre>
				</section>








				<section>
					<p>Не всякая полугруппа является моноидом
				</section>

				<section>
					<p>Но любая полугруппа может им стать, если её завернуть в Option!
				</section>

				<section>
					<p>Option[A] не является ни моноидом, ни полугруппой:
						<br>не определена операция combine
					<p class=fragment>Но Option[A: Semigroup] является!
				</section>


				<section>
					<p>NonEmptyList - полугруппа, но не моноид
				</section>

				<section><pre><code class="scala">final case class NonEmptyList[A](head: A, tail: List[A]) {

  def ++(other: NonEmptyList[A]) =
                        NonEmptyList(head, tail ++ other.toList)

  def toList: List[A] = head :: tail

}</code></pre>
				</section>

				<section>
					<pre><code class="scala">implicit def nonEmptyListSemigroup[A] =
                                new Semigroup[NonEmptyList[A]] {

  def combine(x: NonEmptyList[A], y: NonEmptyList[A]) = x ++ y

}</code></pre>
				</section>


				<section>
					<pre><code class="scala">implicit def optionMonoid[A: Semigroup] = new Monoid[Option[A]]
{
  def empty: Option[A] = None

  def combine(x: Option[A], y: Option[A]): Option[A] =
    x match {
      case None => y
      case Some(xv) =>
        y match {
          case None => x
          case Some(yv) => Some(xv |+| yv)
        }
    }
}</code></pre>
				</section>


				<section>
					<p>Такое комбинирование пролучаем из
						<br>Semigroup.combineAllOption
				</section>

				<section>
					<pre><code class="scala">import cats.data.NonEmptyList

val nel1 = NonEmptyList(1, List(2, 3))
val nel2 = NonEmptyList(4, List(5, 6))</code></pre>
				</section>

				<section>
					<pre><code class="scala">import cats.Monoid
import cats.implicits._

val lifted = List(nel1, nel2).map(nel => Option(nel))

Monoid.combineAll(lifted)
// res8: Option[NonEmptyList[Int]] =
//                   Some(NonEmptyList(1, List(2, 3, 4, 5, 6)))</code></pre>
				</section>









				<section>
					<h2 style="text-transform: none;">MonoidK</h2>
					<p>Моноид над тайп-классами
				</section>

				<section>
					<h2 style="text-transform: none;">Monoid[A]</h2>
					<ul>
						<li>Позволяет комбинировать значения A</li>
						<li class=fragment>Существует "пустое" значение A, которое функционирует как "ноль"</li>
					</ul>
				</section>

				<section>
					<h2 style="text-transform: none;">MonoidK[F]</h2>
					<ul>
						<li>Позволяет комбинировать два значения F[A]</li>
						<li class=fragment>Для любого A существует "пустое" значение F[A]</li>
						<li class=fragment>Комбинация и пустое значение зависят только от структуры F, но не от структуры A</li>
					</ul>
				</section>

				<section>
					<p>Метод empty теперь параметризуется<br>типом элементов
					<pre><code class="scala">Monoid[List[String]].empty
// res0: List[String] = List()

MonoidK[List].empty[String]
// res1: List[String] = List()

MonoidK[List].empty[Int]
// res2: List[Int] = List()</code></pre>
				</section>

				<section>
					<p>Метод combineK теперь параметризуется<br>типом элементов
					<pre><code class="scala">Monoid[List[String]].combine(
             List("hello", "world"),
             List("bye", "moon"))
// res1: List[String] = List("hello", "world", "bye", "moon")

MonoidK[List].combineK[String](
             List("hello", "world"),
             List("bye", "moon"))
// res2: List[String] = List("hello", "world", "bye", "moon")

MonoidK[List].combineK[Int](List(1, 2), List(3, 4))
// res3: List[Int] = List(1, 2, 3, 4)</code></pre>
				</section>


				<section>
					<h2 style="text-transform: none;">SemigroupK</h2>
					<p>Полугруппа над тайп-классами
				</section>







				<section>
					<h2>Функтор</h2>
				</section>

				<section>
					<p>Контейнер с операцией map
					<pre><code class="scala">trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}</code></pre>
					<img src="catfunctor.png" class=fragment>
				</section>

				<section>
					Требования к реализации
					<pre><code class="scala">
fa.map(f).map(g) = fa.map(f.andThen(g))   //composition

fa.map(x => x) = fa                       //identity
					</code></pre>
				</section>

				<section>
					<pre><code class="scala">
new Functor[Option] {
  def map[A, B](fa: Option[A])(f: A => B): Option[B] =
    fa match {
      case None    => None
      case Some(a) => Some(f(a))
    }
}
					</code></pre>
				</section>



				<section>
					<p>Cats предоставляет функцию lift
					<pre><code class="scala">
def lift[A, B](f: A => B): F[A] => F[B] = fa => map(fa)(f)
				</code></pre>
					<p>"превращает" функцию A => B<br>в функцию F[A] => F[B]
				</section>

				<section>
					<pre><code class="scala">
import cats.Functor
import cats.implicits._

val lenOption: Option[String] => Option[Int] =
   Functor[Option].lift(_.length)
					</code></pre><pre class=fragment><code class="scala">
lenOption(Some("abcd"))
// res: Option[Int] = Some(4)
					</code></pre>
				</section>



				<section>
					<p>Cats предоставляет композицию функторов
					<pre><code class="scala">
import cats.Functor
import cats.implicits._

val listOpt = Functor[List] compose Functor[Option]
//Functor[List[Option]]
					</code></pre>
					<pre class=fragment><code class="scala">
listOpt.map( List(Some(1), None, Some(3)) )(_ + 1)
// res: List[Option[Int]] = List(Some(2), None, Some(4))
					</code></pre>
				</section>



				<section>
					<p>Cats предоставляет функцию fproduct
					<pre><code class="scala">
def fproduct[A, B](fa: F[A])(f: A => B): F[(A, B)] =
   map(fa)(a => a -> f(a))
					</code></pre>
					как "map", но возвращает пару
				</section>

				<section>
					<pre><code class="scala">
import cats.Functor
import cats.implicits._

val source = List("Cats", "is", "awesome")
val product = Functor[List].fproduct(source)(_.length)
// res1: List[(String, Int)] =
//    List((Cats,4), (is,2), (awesome,7))
					</code></pre><pre class=fragment><code class="scala">
product.toMap
// res2: Map[String,Int] =
//    Map(Cats -> 4, is -> 2, awesome -> 7)
					</code></pre>
				</section>











				<section>
					<h2>Semigroupal</h2>
					<pre><code class="scala">trait Semigroupal[F[_]] {
  def product[A, B](fa: F[A], fb: F[B]): F[(A, B)]
}</code></pre>
				</section>

				<section>
					<pre><code class="scala">
  new Semigroupal[Option] {

    def product[A, B](fa: Option[A],
                      fb: Option[B]): Option[(A, B)] =

      if (fa.isDefined && fb.isDefined)
        Some((fa.get, fb.get))
      else None

  }</code></pre>
				</section>








				<section>
					<h2>Аппликатив</h2>
					<pre><code class="scala">trait Applicative[F[_]] extends Semigroupal[F] {
  def product[A, B](fa: F[A], fb: F[B]): F[(A, B)]

  def pure[A](a: A): F[A]
}</code></pre>
					<p>Semigroupal с "нулём"
					<p><small>как моноид и полугруппа, но для функций</small>
				</section>


				<section>
					<p>pure "заворачивает" значение в конструктор типа
					<pre class=fragment><code class="scala">trait Applicative[Option] {
  def pure[A](a: A): F[A] = Some(a)
}</code></pre>
					<pre class=fragment><code class="scala">trait Applicative[Future] {
  def pure[A](a: A): F[A] = Future.successful[A](a)
}</code></pre>
					<pre class=fragment><code class="scala">trait Applicative[List] {
  def pure[A](a: A): F[A] = List(a)
}</code></pre>
				</section>


				<section>
					Требования к реализации
					<pre><code class="scala">
fa.product(fb).product(fc) ~ fa.product(fb.product(fc))   //associativity

pure(()).product(fa) ~ fa                       //left identity
fa.product(pure(())) ~ fa                       //right identity
					</code></pre>
				</section>


				<section>
					<p>Эквивалентное определение
					<pre><code class="scala">trait Applicative[F[_]] {
  def ap[A, B](ff: F[A => B])(fa: F[A]): F[B]

  def pure[A](a: A): F[A]
}</code></pre>
				</section>


				<section>
					<p>На самом деле в cats
					<pre><code class="scala">import cats.Functor

trait Applicative[F[_]] extends Functor[F] {
  def ap[A, B](ff: F[A => B])(fa: F[A]): F[B]

  def pure[A](a: A): F[A]

  def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] =
    ap(map(fa)(a => (b: B) => (a, b)))(fb)

  def map[A, B](fa: F[A])(f: A => B): F[B] = ap(pure(f))(fa)

}</code></pre>
				</section>







				<section>
					<p>//TODO применения ap: https://typelevel.org/cats/typeclasses/applicative.html#what-is-ap
				</section>

				<section>
					<p>//TODO Applicatives compose
				</section>

				<section>
					<p>//TODO Traverse
				</section>


				<section>
					<p>//TODO На самом деле иерархия типов в cats гораздо сложнее и есть разные частные случаи - см. доку или исходники
				</section>














				<section>
					<h2>Монада</h2>
					<p>
				</section>










				<section>
					<p>НЕ ЗАБЫТЬ ИСПРАВТЬ ПЛАН!!!!!!!!!!!!!!!
				</section>






				<section>
					<p>Напоминаю:
					<ul>
						<li>Страничка курса: <br><a href="https://maxcom.github.io/scala-course-2022/">https://maxcom.github.io/scala-course-2022/</a>
					</ul>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
                                controls: true,
                                progress: true,
                                history: true,
                                center: true,

                                transition: 'slide', // none/fade/slide/convex/concave/zoom

				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
