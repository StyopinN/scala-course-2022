<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Cats и Circe</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Часть 11. Cats Effect & Http4s</h3>
					<p><small>Страничка курса: <a href="https://maxcom.github.io/scala-course-2022/">https://maxcom.github.io/scala-course-2022/</a></small></p>

					<aside class="notes">
						Добрый день.<p>
						Это 11 лекция курса по программированию на языке Scala.<p>
						На этой лекции мы проведём обзор двух библиотек из экосистемы Typelevel: cast-effect и http4s.
					</aside>
				</section>

				<section>
					<h3>План</h3>
					<ol>
						<li>Эффекты</li>
						<li>IO vs Future</li>
						<li>Http4s</li>
					</ol>

					<aside class="notes">
						В начале мы познакомимся с понятием эффектов в программировании.<p>
						Далее рассмотрим монаду IO, которая предлагается в библиотеке cats-effect как альтернатива для стандартного Future, и сравним их между собой.<p>
						В конце лекции сделаем быстрый обзор на минималистичный сервер http4s, который очень прост в использовании и отлично сочетается с cats-effect.
					</aside>
				</section>






				<section>
					<h3>Чистая функция</h3>
					<ul>
						<li>Является детерминированной</li>
						<li>Не обладает побочными эффектами (side-effect)</li>
					</ul>

					<aside class="notes">
						Считается, что в идеальном функциональном мире любая функция должна быть чистой
						(т.е. детерминированной и не обладать побочными эффектами).<p>
						Напомню, что детерминированность означает, что сколько бы раз вы ни вызывали функцию,
						на одних и тех же входных данных она будет давать всегда один и тот же ответ.<p>
						Теперь давайте вспомним, что такое побочные эффекты.
					</aside>
				</section>


				<section>
					<h3>Побочный эффект</h3>
					<ul>
						<li>Создание или изменение файла</li>
						<li>Запись данных в базу</li>
						<li>Изменение глобальной переменной (увеличение счётчика)</li>
						<li class=fragment>Модификация переданной в функцию переменной</li>
						<li class=fragment>Изменение своего дальнейшего поведения</li>
						<li class=fragment>Вызов внешней функции, имеющей любой из перечисленных выше эффектов</li>
					</ul>

					<aside class="notes">
						Представим, что мы хотим, чтобы в результате каких-то вычислений, в результате получения новой информации или команды
						программа что-то записала в базу данных или в файл или изменила значение счётчика.<p>
						Всё это - изменения каких-то ВНЕШНИХ по отношению к программе "ресурсов".<hr>
						В частности к изменению таких внешних ресурсов относится и модификация переданной в функцию переменной.<hr>
						Также к побочным эффектам относится изменение своего внутреннего состояния таким образом,
						что в дальнейшем внешние проявления в поведении программы будет отличаться от предыдущих.<hr>
						И, наконец, вызов какой-то внешней функции, приводящий к любому из этих последствий, также будет нарушать чистоту нашей функции и считаться side-effect-ом.
					</aside>
				</section>


				<section>
					<p>Чистые функции - это хорошо?</p>

					<aside class="notes">
						Так почему же чистые функции - это хорошо?<p>
						Как правило, наличие side-effect-а влечёт за собой нарушение детерминированности.<p>
						Но бывает и что-то одно: только детерминированные функции без side-эффектов.
						Например, функция random или функция получения значения из какой-то глобальной переменной. Или функция чтения из базы данных или файла.<p>
						И наоборот, функции с side-эффектами, но при этом детерминированные. Например, функция print, которая всегда возвращает 0.
					</aside>
				</section>

				<section>
					<h3>Чистые функции</h3>
					<ul>
						<li>Делают код более предсказуемым</li>
						<li>Решают проблемы многопоточности</li>
						<li>Позволяют кешировать результат</li>
						<li>Можно менять местами последовательность вызова двух чистых функций</li>
					</ul>

					<aside class="notes">
						В любом случае функции, не являющиеся чистыми, делают поведение программы труднопредсказуемым и не однозначным.<p>
						Начинают вылезать странности при одновременном вызове одной и той же функции в нескольких потоках.
						Например, когда несколько пользователей запрашивают что-то у сервиса, то могут получить различные результаты в зависимости от порядка выполнения запросов.<p>
						Реализовывать асинхронные программы становится сложнее, потому что результаты одного потока могут зависить от выполнения другого потока.<p>
						Все эти проблемы решаются чистыми функциями.<p>
						Более того, чистые функции позволяют кешировать результат и заменять вызов функции на значение её результата.
						А ещё можно смело менять последовательность вызова таких функций не опасаясь за результат.
						<p>
						Но что же делать, если почти всегда "полезными результатами" работы программы являются какие-то побочные эффекты?
						Ведь вся цель написания программы - это выполнить какие-то действия и что-то поменять в окружающем мире!
					</aside>
				</section>

				<section>
					<h3>Resource</h3>
					<p>Внешний относительно функции объект,<br>который может меняться со временем</p><p>(не обязательно побочными эффектами<br>данной функции)</p>

					<aside class="notes">
						Здесь на помощь приходит понятие "ресурса".
						Это некоторый "внешний" относительно функции объект, который может менять своё состояние с течением времени.
						Например, это может быть тот же файл на диске, база данных, глобальная переменная, консоль ввода-вывода, какая-нибудь стейт-машина.<p>
						В итоге всё сводится к тому, чтобы максимально локализовать работу с ресурсами и
						обеспечить безопасное использование ресурсов несколькими потоками.
					</aside>
				</section>

				<section>
					<p>Методы для работы с ресурсами стоит рассматривать как единичное и неделимое действие,
						а в конце этих действий нужно полностью освобождать ресурс</p>

					<aside class="notes">
						Методы для работы с ресурсами лучше всего рассматривать как единичное и неделимое действие,
						а в конце этих действий нужно полностью освобождать ресурс.<p>
						Вся остальная программа при этом состоит из чистых функций, из которых разработчик проектирует как из кирпичиков,
						и обращение к ресурсам становится максимально похоже на эти кирпичики.<p>
						При таком подходе работа с ресурсами становится гораздо более предсказуемой и максимально близкой к чистым функциям,
						с тем лишь исключением, что остаётся некоторый "внешний эффект":
						Например, записанные в этот ресурс данные или изменённое состояние ресурса.<p>
						Заметим, что, текущее состояния объекта можно рассматривать, как некоторую информацию, которую этот объект содержит.
						Поэтому нет никого смысла рассматривать этот случай отдельно.
					</aside>
				</section>





				<section>
					<div><img src="cats-effect-logo.svg" height="200" style="background: none; border: 0; box-shadow: none;"></div>
					<h3>Cats Effect</h3>
					<small><a href="https://typelevel.org/cats-effect">https://typelevel.org/cats-effect</a></small>

					<aside class="notes">
						С тем, что такое эффекты и как с ними лучше работать мы разобрались.
						Теперь давайте посмотрим, что нам предлагает библиотека cats effect.
					</aside>
				</section>

				<section>
					<h3>Cats Effect</h3>
					<p>"Высокопроизводительная асинхронная компонуемая платформа для создания приложений в чистом функциональном стиле"</p>

					<aside class="notes">
						Вот какое определение красуется на главной странице ресурса:
						Cats Effect - это "Высокопроизводительная асинхронная компонуемая платформа для создания приложений в чистом функциональном стиле".
						Она предоставляет инструмент, известный как «IO монада», ...
					</aside>
				</section>

				<section>
					<h3>IO monad</h3>
					<ul>
						<li>Безопасное использование и управление ресурсами</li>
						<li>Типизированность</li>
						<li>Параллельность (Fiber - легковесные потоки, управляемые средой выполнения)</li>
						<li>Асинхронность (callback-driven) или синхронность</li>
						<li>Конечное или бесконечное время выполнения</li>
					</ul>

					<aside class="notes">
						... который позволяет управлять эффектами и следить за жизненным циклом ресурсов, безопасно выделять и освобождать их.<p>
						При этом эффекты могут быть как асинхронными (т.е. вызывать callback-функцию по окончании действия)
						так и синхронными (т.е. непосредственно возвращающими значения).<p>
						Параллелизму здесь способствует понятие "волокон" (в оригинале: Fiber),
						которые представляют собой легковесные прерываемые потоки, полностью управляемые средой выполнения.<p>
						Эти волокна намного дешевле, чем нативные потоки операционной системы, поэтому можно создавать их в огромном количестве.<p>
						Интересной особенностью IO-монады является её способность не только выполнить какое-то действие и вернуть результат, но и выпоняться бесконечно.
						Дальше мы увидим подобные примеры.<p>
						Стоит также сказать, что IO-монада является типизированной, но этим уже мало кого удивишь.
					</aside>
				</section>


				<section>
					<h3 style="text-transform: none;">IO vs Future</h3>

					<aside class="notes">
						Несмотря на внешнее сходство с Future, IO имеет несколько существенных отличий,
						которые заметно расширяют возможности разработчика контролировать поведением асинхронных вычислений.<p>
						Чтобы увидеть это, давайте глубже познакомимся с синтаксисом
					</aside>
				</section>
								
				<section>
					<pre><code class="scala"> object Future {
   def apply[A](body: => A): Future[A]
 }</code></pre>
					<pre><code class="scala"> object IO {
   def apply[A](body: => A): IO[A]
 }</code></pre>
 
					<aside class="notes">
						Для начала посмотрим на конструктор.
						На первый взгляд, они абсолютно одинаковые: в обоих случаях мы передаёт тело функции как by-name параметр.
						(т.е. оно будет выполнено только в момент непосредственного использования).
						Но внутри Future сразу запускает вычисление и возвращает некоторую сущность,
						которая по окончании вычисления будет содержать полученное значение.
						В дальнейшем мы можем обращаться к ней несколько раз и получать это значение.<p>
						IO действует иначе.
						Возвращается контейнер с функцией, но вычисление ещё не запускалось.
						Оно будет запущено только когда мы попытаемся получить значение.
						При этом если мы будем обращаться к значению несколько раз, то оно будет вычисляться заново!
					</aside>
				</section>
						
				<section>
					<table>
					<tr>
						<td></td>
						<td><b>Eager<br><small>with Memo</small></b></td>
						<td><b>Lazy<br><small>with Memo</small></b></td>
						<td><b>Lazy<br><small>without Memo</small></b></td>
					</tr>
					<tr>
						<td><b>Sync</b></td>
						<td>val<br><small>A</small></td>
						<td>lazy val<br><small> => A</small></td>
						<td>def<br><small>() => A</small></td>
					</tr>
					<tr>
						<td><b>Async</b></td>
						<td>Future[A]<br><small>(A => Unit) => Unit</small></td>
						<td></td>
						<td>IO[A]<br><small>() => (A => Unit) => Unit</small></td>
					</tr>
					</table>
					
					<aside class="notes">
						Можно провести аналогию с val и def:
						val сразу вычисляет значение и возвращает его, сколько бы раз мы не обращались.
						def вычисляет только при обращении, причём делает это каждый раз.
						В случае future и io происходит тоже самое, но вычисляется в другом потоке.
						<p>
						Таким образом, в отличие от Future, IO представляет собой ОПИСАНИЕ куска программы, а не текущие вычисления.
						Это дает полный контроль над тем, как и когда будут выполняться эффекты.
						Простые программы могут быть использованы для составления более сложных программ,
						сохраняя при этом своё поведение и сложность.
					</aside>
				</section>

				<section>
					<div><img src="Dynamite Effects.png"></div>
					<aside class="notes">
						Работа с Future при написании программы напоминает попытку собрать сложное устройство из заранее запущенных механизмов.
						Если делать запустить сразу много потоков, или действовать неаккуратно,
						можно легко получить проблему и непредсказуемый результат.<p>
						IO позволяет нам конструировать программу из действий, которые ещё не запущены,
						но будут выполнены в дальнейшем по нашей команде.
					</aside>
				</section>
				
				<section>
					<div>IO evaluated at the "end of the world"</div>
					<aside class="notes">
						Обычно говорят, что IO запускается "at the end of the world
						(т.е. подчёркивается, что мы сначала всё конструируем, а запускаем в самом конце)
					</aside>
				</section>
				
				<section>
					<pre><code class="scala"> val addToGauge = IO {
   ???
   println("Added!")
 }

 val program: IO[Unit] =
   for {
      _ <- addToGauge
      _ <- addToGauge
   } yield ()

 program.unsafeRunSync()
 // Added!
 // Added!</code></pre>
					<aside class="notes">
						Вот как это обычно выглядит на практике.
						Представьте, что у вас есть какие-то кусочки программы, завёрнутые в IO.
						Например, кусок кода, который увеличивает счётчик и печатает сообщение об этом.
						<p>
						Воспользуемся тем, что IO - это монада, а значит у неё есть метод flatMap,
						доступны различные трансформеры, которые позволяют "накручивать" конструкцию
						и конечно же можно использовать красивый и наглядный синтаксис for.
						<p>
						Когда конструкция будет собрана, то в конце запускается метод run и получается результат.
						<p>
						Обратите внимание, что в данном случае метод print выполнился два раза.
						Если бы мы использовали Future, то счётчик был бы увеличен только один раз.
					</aside>
				</section>
				
				<section>
					<div>Stack Safety</div>
					<aside class="notes">
						Ещё одно существенное отличие от Future - это безопасность относительно переполнения стека.<p>
						Возьмём классический пример: вычисления чисел Фиббоначи.
					</aside>
				</section>
				
				<section>
					<pre><code class="scala"> def fib(n: Int, a: Long = 0, b: Long = 1): IO[Long] =
   IO(a + b).flatMap { b2 =>
     if (n > 0) 
       fib(n - 1, b, b2)
     else 
       IO.pure(a)
 }</code></pre>
					<div class=fragment>IO is <b>trampolined</b> in its <b>flatMap</b> evaluation</div>
					<aside class="notes">
						В случае с IO мы можем записать его в таком виде.
						Здесь используется рекурсия, но не хвостовая: последним действием здесь является flatMap.
						Для Future это вызвало бы Stack Overflow, но для IO такая конструкция допустима.
						<hr>
						Такое поведение называется "трамплином" относительно flatMap.
					</aside>
				</section>
						
				<section>
					<pre><code class="scala"> object IO {
   //side effect is not thread-blocking:
   def apply[A](thunk: => A): IO[A] //alias for delay
   def delay[A](thunk: => A): IO[A]

   //side effect is thread-blocking:
   def blocking[A](thunk: => A): IO[A]      //uncancelable
   def interruptible[A](thunk: => A): IO[A] //cancelable
   def interruptibleMany[A](thunk: => A): IO[A]
 }</code></pre>
 
					<aside class="notes">
						Помимо стандартного конструктора, который принимает by-name параметром отложенное вычисление,
						существуют и другие способы создать IO.<p>
						Например, метод есть метод delay, который имеет чуть более говорящее название, но на самом деле это просто его синоним.<p>
						Эти конструкторы подходят только для неблокирующих операций.<p>
						Для блокирующих нужно использовать либо конструктор blocking, который является непрерываемым,<br>
						либо прерываемый interruptible.<p>
						Обратите внимание, что для прерывания interruptable будет предпринята только одна попытка,<br>
						в то время как его разновидность interruptibleMany будет получать повторяемые попытки прерывания
						до тех пор, пока блокирующая операция не завершится или не выйдет.<p>
						Все перечисленные конструкторы имеют одинаковую семантику и отличие только в логике работы
						(и, соответственно, в проихводительности).<br>
						Например, interruptable будет работать заметно медленнее, чем blocking,
						потому что имеет дополнительный оверхед от координации прерываний.
					</aside>
				</section>
				
				<section>
					<pre><code class="scala"> object IO {
   def defer[A](thunk: => IO[A]): IO[A]
   
   def race[A, B](left: IO[A], right: IO[B]): IO[Either[A, B]]
 }</code></pre>
 
					<aside class="notes">
					???
					</aside>
				</section>
				
				<section>
					<pre><code class="scala"> object IO {
   def async_[A](
     k: ((Either[Throwable, A]) => Unit) => Unit
   ): IO[A]
   
   def async[A](
     k: ((Either[Throwable, A]) => Unit) => IO[Option[IO[Unit]]]
   ): IO[A]
 }</code></pre>
 
					<aside class="notes">
					???
					</aside>
				</section>
				
				<section>
					<pre><code class="scala"> object IO {
   def pure[A](value: A): IO[A]           //already evaluated
   def canceled: IO[Unit]                 //already cancelled
   def raiseError[A](t: Throwable): IO[A] //already throwed
   
   def stub: IO[Nothing]
   def unit: IO[Unit]                     //alias for IO.pure(())
   def none[A]: IO[Option[A]]             //contains None
   def some[A](a: A): IO[Option[A]]       //contains Some(a)
   
   def raiseUnless(cond: Boolean)(e: => Throwable): IO[Unit]
   def raiseWhen(cond: Boolean)(e: => Throwable): IO[Unit]
   
   def never[A]: IO[A]                    //alias for async(_ => ())
 }</code></pre>
 
					<aside class="notes">
						Разумеется есть и вырожденные варианты.<p>
						Например, pure, canceled и raiseError создают IO, получая параметр не по имени, а по значению,
						подставляя уже вычисленное значение, ошибку или создавая изначально прерванную IO.<p>
						Конструктор some действует аналогично pure, но дополнительно оборачивает значение в Some.
						Есть также совсем вырожденные случаи stub, unit и none.<p>
						Более интересные варианты: raiseUnless и raiseWhen,<br>
						- которые очень часто используются на практике для проверки условий и прерываний последовательности действиу внутри for.<p>
						Отдельно стоит обратить внимание на IO.never. Это действие, которое никогда не завершится.<br>
						На самом деле это просто алиас для async, который ничего не делает и никогда не вызывает callback,<br>
						но он имеет очень интересное практическое значение и способы применения, которые мы увидим дальше.
					</aside>
				</section>

				<section>
					<pre><code class="scala"> object IO {
   def fromEither[A](e: Either[Throwable, A]): IO[A]
   def fromFuture[A](fut: IO[Future[A]]): IO[A]
   def fromOption[A](o: Option[A])(orElse: => Throwable): IO[A]
   def fromTry[A](t: Try[A]): IO[A]
 }</code></pre>
 
					<aside class="notes">
					Также есть методы для трансформирования в IO из других типов, которые сводятся к одному из двух вариантов: успех или не успех.
					Например, Either, Future, Option или Try
					</aside>
				</section>
				


				<!----------------------------------------------->
				<!-------------------- DRAFT -------------------->
				<!----------------------------------------------->

				<section>
					<h3>Рассказать</h3>
					<ul>
						<li>cancelation / uncancelable marker</li>
						<li>run-ы: runCancelable / unsafeRunCancelable</li>
						<li>Иерархия</li>
						<li>ресурсы</li>
						<li>Thread Shifting</li>
						<li>IOApp - https://typelevel.org/cats-effect/docs/2.x/datatypes/ioapp</li>
						
						<small>
						<li>https://typelevel.org/cats-effect/docs/2.x/datatypes/io</li>
						<li>https://typelevel.org/cats-effect/docs/2.x/typeclasses/async</li>
						<li>https://typelevel.org/cats-effect/docs/2.x/typeclasses/overview</li>
						</small>
					</ul>
				</section>
				
				<section>
					<h3>Fibers</h3>
					<p>https://typelevel.org/cats-effect/docs/concepts</p>
					<aside class="notes">
						Волокна — это фундаментальная абстракция в Cats Effect.
						Терминология намеренно напоминает потоки, поскольку волокна — это буквально легкие потоки
						(часто называемые «зелеными потоками» или «сопрограммами»).
						Подобно потокам, они представляют собой последовательность действий,
						которые в конечном итоге будут оцениваться базовым оборудованием в указанном порядке.
						Волокна расходятся с потоками в их следе и уровне абстракции.

						Волокна очень легкие.
						Среда выполнения Cats Effect IO реализует волокна размером примерно 150 байт на волокно,
						а это означает, что вы можете буквально без проблем создавать десятки миллионов волокон в одном и том же процессе,
						и вашим основным ограничивающим фактором будет просто память.
						Например, любое клиент-серверное приложение, определенное с помощью Cats Effect,
						будет создавать новое волокно для каждого входящего запроса, подобно тому, как простой сервер,
						написанный с использованием Java ServerSocket, будет создавать новый поток для каждого запроса
						(за исключением того, что это одновременно безопасно и быстро).
						сделайте это с волокнами!).
						Поскольку они очень легкие, процесс создания и запуска нового волокна сам по себе чрезвычайно быстр,
						что позволяет создавать очень недолговечные, «одноразовые» волокна, когда это удобно.
						Многие функции в Cats Effect реализованы в терминах волокон под поверхностью,
						даже те, которые не включают параллелизм (например, memoize).

						асинхронная поддержка имеет серьезные последствия, так как это означает,
						что любой отдельный «шаг» волокна (во многом похожий на оператор в потоке)
						может быть либо синхронным в том смысле, что он выполняется до тех пор, пока не выдаст значение или ошибку,
						либо асинхронным в том, что он регистрирует обратный вызов,
						который может быть вызван извне в какой-то более поздний момент,
						и между этими шагами нет принципиальной разницы: они просто часть волокна.
						Иными словами: с волокнами нет разницы между обратным вызовом и возвратом.
						Это означает, что определить бизнес-логику, которая переплетается с асинхронными действиями,
						ориентированными на обратный вызов, так же просто, как и определить ту же логику в терминах классической блокировки потоков управления.

						Обычно
						Каждый шаг в потоке представляет собой оператор, и эти операторы определяются последовательно,
						записывая их в определенном порядке в текстовом файле, объединяя вместе с помощью оператора точки с запятой (;).
						Аналогично
						Каждый шаг в волокне является эффектом, и эти эффекты определяются последовательно путем их
						явного составления с помощью функции flatMap.

						Каждый шаг волокна является эффектом, и объединение шагов вместе дает больший эффект, который, в свою очередь, может продолжать компоноваться.

						Каждое приложение имеет «основное волокно».
						Это очень похоже на понятие «основной поток» в том смысле, что это точка, в которой начинается поток управления внутри процесса.
						Традиционно в Cats Effect это основное волокно определяется с помощью IOApp и, в частности, эффектом, возвращаемым методом run:
					</aside>
					<pre><code class="scala"> object Main extends IOApp.Simple {
   val run = IO.println("Hello") >> IO.println("World")
 }</code></pre>
					<aside class="notes">
						В этом примере Main является основным классом.
						Когда он вызывается извне (например, с помощью команды java или с узлом при использовании ScalaJS),
						он запускает основной файбер и работает до тех пор, пока этот файбер не завершится, после чего процесс будет остановлен.

						Когда одно волокно начинает другое волокно, мы обычно говорим, что первое волокно является «родителем» второго.
						Эта связь не является прямо иерархической в том смысле, что родитель может завершиться раньше дочернего,
						не вызывая каких-либо несоответствий.
						Тем не менее, некоторые свойства модели волокон имеют гораздо больше смысла,
						если иметь в виду отношения родитель/потомок.
						Например, файберы всегда могут наблюдать за ошибками и восстанавливаться после них
						(с помощью чего-то вроде handleErrorWith или attempt).
						Это концептуально похоже на try/catch.
						Волокна также могут наблюдать собственную отмену (см. ниже), но они не могут восстановиться после нее,
						то есть не могут продолжать выполнение после отмены.
						Родительские волокна могут инициировать отмену в дочернем элементе (с помощью метода cancel)
						и могут наблюдать окончательный результат этого дочернего элемента (который может быть отменен)
						и могут продолжать выполнение после завершения дочернего элемента.
					</aside>
				</section>

				<section>
					<h3>Asynchronous</h3>
					<p>https://typelevel.org/cats-effect/docs/concepts#asynchronous</p>
					+ в конце страницы:
					<pre><code class="scala">
					In Cats Effect, code containing side-effects should always be wrapped in one of the "special" constructors. In particular:

					Synchronous (returns or throws)
					IO(...) or IO.delay(...)
					IO.blocking(...)
					IO.interruptible(...)
					IO.interruptibleMany(...)
					Asynchronous (invokes a callback)
					IO.async or IO.async_
					</code></pre>
				</section>

				<section>
					<h3>Cancelation</h3>
					<p>https://typelevel.org/cats-effect/docs/concepts#cancelation</p>
				</section>
				<section>
					<h3>Dealing with cancelation</h3>
					<p>https://typelevel.org/cats-effect/docs/tutorial#dealing-with-cancelation</p>
				</section>
				<section>
					<h3>Dealing with cancelation</h3>
					<p>https://typelevel.org/cats-effect/docs/tutorial#dealing-with-cancelation</p>
				</section>
				<section>
					<h3>Рассказать про ресурсы</h3>
				</section>




				<section>
					<h3>Http4s</h3>
					<p>???</p>
				</section>

				<section>
					<h3>???</h3>
					<p>???</p>

					<aside class="notes">
						На ближайшем семинаре мы с вами попробуем построить сервер с использованием рассмотренных сегодня библиотек.
					</aside>
				</section>

				<!----------------------------------------------->
				<!-------------------- DRAFT -------------------->
				<!----------------------------------------------->

				<section>
					<p>Напоминаю:
					<ul>
						<li>Страничка курса: <br><a href="https://maxcom.github.io/scala-course-2022/">https://maxcom.github.io/scala-course-2022/</a>
					</ul>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
                                controls: true,
                                progress: true,
                                history: true,
                                center: true,

                                transition: 'slide', // none/fade/slide/convex/concave/zoom

				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
