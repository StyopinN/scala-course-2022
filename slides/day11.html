<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Cats и Circe</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>Часть 11. Cats Effect & Http4s</h3>
					<p><small>Страничка курса: <a href="https://maxcom.github.io/scala-course-2022/">https://maxcom.github.io/scala-course-2022/</a></small></p>

					<aside class="notes">
						Добрый день.<p>
						Это 11 лекция курса по программированию на языке Scala.<p>
						На этой лекции мы проведём обзор двух библиотек из экосистемы Typelevel: cast-effect и http4s.
					</aside>
				</section>

				<section>
					<h3>План</h3>
					<ol>
						<li>Эффекты</li>
						<li>IO vs Future</li>
						<li>Http4s</li>
					</ol>

					<aside class="notes">
						В начале мы познакомимся с понятием эффектов в программировании.<p>
						Далее рассмотрим монаду IO, которая предлагается в библиотеке cats-effect как альтернатива для стандартного Future, и сравним их между собой.<p>
						В конце лекции сделаем быстрый обзор на минималистичный сервер http4s, который очень прост в использовании и отлично сочетается с cats-effect.
					</aside>
				</section>






				<section>
					<h3>Чистая функция</h3>
					<ul>
						<li>Является детерминированной</li>
						<li>Не обладает побочными эффектами (side-effect)</li>
					</ul>

					<aside class="notes">
						Считается, что в идеальном функциональном мире любая функция должна быть чистой
						(т.е. детерминированной и не обладать побочными эффектами).<p>
						Напомню, что детерминированность означает, что сколько бы раз вы ни вызывали функцию,
						на одних и тех же входных данных она будет давать всегда один и тот же ответ.<p>
						Теперь давайте вспомним, что такое побочные эффекты.
					</aside>
				</section>


				<section>
					<h3>Побочный эффект</h3>
					<ul>
						<li>Создание или изменение файла</li>
						<li>Запись данных в базу</li>
						<li>Изменение глобальной переменной (увеличение счётчика)</li>
						<li class=fragment>Модификация переданной в функцию переменной</li>
						<li class=fragment>Изменение своего дальнейшего поведения</li>
						<li class=fragment>Вызов внешней функции, имеющей любой из перечисленных выше эффектов</li>
					</ul>

					<aside class="notes">
						Ппредставим, что мы хотим, чтобы в результате каких-то вычислений, в результате получения новой информации или команды
						программа что-то записала в базу данных или в файл или изменила значение счётчика.<p>
						Всё это - изменения каких-то ВНЕШНИХ по отношению к программе "ресурсов".<hr>
						В частности к изменению таких внешних ресурсов относится и модификация переданной в функцию переменной.<hr>
						Также к побочным эффектам относится изменение своего внутреннего состояния таким образом,
						что в дальнейшем внешние проявления в поведении программы будет отличаться от предыдущих.<hr>
						И, наконец, вызов какой-то внешней функции, приводящий к любому из этих последствий, также будет нарушать чистоту нашей функции и считаться side-effect-ом.
					</aside>
				</section>


				<section>
					<p>Чистые функции - это хорошо?</p>

					<aside class="notes">
						Так почему же чистые функции - это хорошо?<p>
						Как правило, наличие side-effect-а влечёт за собой нарушение детерминированности.<p>
						Но бывает и что-то одно: только детерминированные функции без side-эффектов.
						Например, функция random или функция получения значения из какой-то глобальной переменной. Или функция чтения из базы данных или файла.<p>
						И наоборот, функции с side-эффектами, но при этом детерминированные. Например, функция print, которая всегда возвращает 0.
					</aside>
				</section>

				<section>
					<h3>Чистые функции</h3>
					<ul>
						<li>Делают код более предсказуемым</li>
						<li>Решают проблемы многопоточности</li>
						<li>Позволяют кешировать результат</li>
						<li>Можно менять местами последовательность вызова двух чистых функций</li>
					</ul>

					<aside class="notes">
						В любом случае функции, не являющиеся чистыми, делают поведение программы труднопредсказуемым и не однозначным.<p>
						Начинают вылезать странности при одновременном вызове одной и той же функции в нескольких потоках.
						Например, когда несколько пользователей запрашивают что-то у сервиса, то могут получить различные результаты в зависимости от порядка выполнения запросов.<p>
						Реализовывать асинхронные программы становится сложнее, потому что результаты одного потока могут зависить от выполнения другого потока.<p>
						Все эти проблемы решаются чистыми функциями.<p>
						Более того, чистые функции позволяют кешировать результат и заменять вызов функции на значение её результата.
						А ещё можно смело менять последовательность вызова таких функций не опасаясь за результат.
						<p>
						Но что же делать, если почти всегда "полезными результатами" работы программы являются какие-то побочные эффекты?
						Ведь вся цель написания программы - это выполнить какие-то действия и что-то поменять в окружающем мире!
					</aside>
				</section>

				<section>
					<h3>Resource</h3>
					<p>Внешний относительно функции объект,<br>который может меняться со временем</p><p>(не обязательно побочными эффектами<br>данной функции)</p>

					<aside class="notes">
						Здесь на помощь приходит понятие "ресурса".
						Это некоторый "внешний" относительно функции объект, который может менять своё состояние с течением времени.
						Например, это тот же файл на диске, база данных, глобальная переменная, консоль ввода-вывода, какая-нибудь стейт-машина.<p>
						В итоге всё сводится к тому, чтобы максимально локализовать работу с ресурсами и
						обеспечить безопасное использование ресурсов несколькими потоками.
					</aside>
				</section>

				<section>
					<p>Методы для работы с ресурсами стоит рассматривать как единичное и неделимое действие,
						а в конце этих действий нужно полностью освобождать ресурс</p>

					<aside class="notes">
						Методы для работы с ресурсами стоит рассматривать как единичное и неделимое действие,
						а в конце этих действий нужно полностью освобождать ресурс.<p>
						Тогда работа с ресурсами становится гораздо более предсказуемой и максимально близкой к чистым функциям, с тем лишь исключением, что остаётся внешний "эффект":
						записанные в этот ресурс данные или изменённое состояние ресурса (что, в общем-то, тоже можно рассматривать, как записанную в него информацию).
						Вся остальная программа при этом состоит из чистых функций, из которых всё строится как из кирпичиков,
						и обращение к ресурсам становится максимально похоже на эти кирпичики.
					</aside>
				</section>





				<section>
					<div><img src="cats-effect-logo.svg" height="200" style="background: none; border: 0; box-shadow: none;"></div>
					<h3>Cats Effect</h3>
					<small><a href="https://typelevel.org/cats-effect">https://typelevel.org/cats-effect</a></small>

					<aside class="notes">
						С тем, что такое эффекты и как с ними лучше работать мы разобрались.
						Теперь давайте посмотрим, что нам предлагает библиотека cats effect.
					</aside>
				</section>

				<section>
					<h3>Cats Effect</h3>
					<p>"Высокопроизводительная асинхронная компонуемая платформа для создания приложений в чистом функциональном стиле"</p>

					<aside class="notes">
						Вот какое определение красуется на главной странице ресурса:
						Cats Effect - это "Высокопроизводительная асинхронная компонуемая платформа для создания приложений в чистом функциональном стиле".
						Она предоставляет инструмент, известный как «IO монада», ...
					</aside>
				</section>

				<section>
					<h3>IO monad</h3>
					<ul>
						<li>Безопасное использование и управление ресурсами</li>
						<li>Типизированность</li>
						<li>Параллельность (Fiber - легковесные потоки, управляемые средой выполнения)</li>
						<li>Асинхронность (callback-driven) или синхронность</li>
						<li>Конечное или бесконечное время выполнения</li>
					</ul>

					<aside class="notes">
						... который позволяет управлять эффектами и следить за жизненным циклом ресурсов, безопасно выделять и освобождать их.<p>
						При этом эффекты могут быть как асинхронными (т.е. вызывать callback-функцию по окончании действия)
						так и синхронными (т.е. непосредственно возвращающими значения).<p>
						Параллелизму здесь способствует понятие "волокон" (в оригинале: Fiber),
						которые представляют собой легковесные прерываемые потоки, полностью управляемые средой выполнения.<p>
						Эти волокна намного дешевле, чем нативные потоки операционной системы, поэтому можно создавать их в огромном количестве.<p>
						Интересной особенностью IO-монады является её способность не только выполнить какое-то действие и вернуть результат, но и выпоняться бесконечно.
						Дальше мы увидим подобные примеры.<p>
						Стоит также сказать, что IO-монада является типизированной, но этим уже мало кого удивишь.
					</aside>
				</section>


				<section>
					<h3 style="text-transform: none;">IO vs Future</h3>

					<aside class="notes">
						Несмотря на внешнее сходство с Future, IO имеет несколько существенных отличий,
						которые заметно расширяют возможности разработчика контролировать поведением асинхронных вычислений.<p>
						Чтобы увидеть это, давайте глубже познакомимся с библиотекой
					</aside>
				</section>

				<section>
					??? (встаить табличку с отложенным запуском IO и сравнение с Future)
					<aside class="notes">
						В отличие от Future, IO представляет собой ОПИСАНИЕ программы, а не текущие вычисления.
						Это дает полный контроль над тем, как и когда будут выполняться эффекты.
						Простые программы могут быть использованы для составления более сложных программ,
						сохраняя при этом своё поведение и сложность.
					</aside>
				</section>

				<section>
					<div><img src="Dynamite Effects.png"></div>
					<aside class="notes">
						Работа с Future напоминает попытку собрать устройство из заранее запущенных механизмов.
						Если делать всё слишком долго, запустить сразу много потоков, или действовать неаккуратно,
						можно легко получить проблему и непредсказуемый результат.<p>
						IO позволяет нам конструировать программу из действий, которые ещё не запущены,
						но будут выполнены в дальнейшем по нашей команде.
					</aside>
				</section>



				<!----------------------------------------------->
				<!-------------------- DRAFT -------------------->
				<!----------------------------------------------->

				<section>
					<h3>Fibers</h3>
					<p>https://typelevel.org/cats-effect/docs/concepts</p>
					<aside class="notes">
						Волокна — это фундаментальная абстракция в Cats Effect.
						Терминология намеренно напоминает потоки, поскольку волокна — это буквально легкие потоки
						(часто называемые «зелеными потоками» или «сопрограммами»).
						Подобно потокам, они представляют собой последовательность действий,
						которые в конечном итоге будут оцениваться базовым оборудованием в указанном порядке.
						Волокна расходятся с потоками в их следе и уровне абстракции.

						Волокна очень легкие.
						Среда выполнения Cats Effect IO реализует волокна размером примерно 150 байт на волокно,
						а это означает, что вы можете буквально без проблем создавать десятки миллионов волокон в одном и том же процессе,
						и вашим основным ограничивающим фактором будет просто память.
						Например, любое клиент-серверное приложение, определенное с помощью Cats Effect,
						будет создавать новое волокно для каждого входящего запроса, подобно тому, как простой сервер,
						написанный с использованием Java ServerSocket, будет создавать новый поток для каждого запроса
						(за исключением того, что это одновременно безопасно и быстро).
						сделайте это с волокнами!).
						Поскольку они очень легкие, процесс создания и запуска нового волокна сам по себе чрезвычайно быстр,
						что позволяет создавать очень недолговечные, «одноразовые» волокна, когда это удобно.
						Многие функции в Cats Effect реализованы в терминах волокон под поверхностью,
						даже те, которые не включают параллелизм (например, memoize).

						асинхронная поддержка имеет серьезные последствия, так как это означает,
						что любой отдельный «шаг» волокна (во многом похожий на оператор в потоке)
						может быть либо синхронным в том смысле, что он выполняется до тех пор, пока не выдаст значение или ошибку,
						либо асинхронным в том, что он регистрирует обратный вызов,
						который может быть вызван извне в какой-то более поздний момент,
						и между этими шагами нет принципиальной разницы: они просто часть волокна.
						Иными словами: с волокнами нет разницы между обратным вызовом и возвратом.
						Это означает, что определить бизнес-логику, которая переплетается с асинхронными действиями,
						ориентированными на обратный вызов, так же просто, как и определить ту же логику в терминах классической блокировки потоков управления.

						Обычно
						Каждый шаг в потоке представляет собой оператор, и эти операторы определяются последовательно,
						записывая их в определенном порядке в текстовом файле, объединяя вместе с помощью оператора точки с запятой (;).
						Аналогично
						Каждый шаг в волокне является эффектом, и эти эффекты определяются последовательно путем их
						явного составления с помощью функции flatMap.

						Каждый шаг волокна является эффектом, и объединение шагов вместе дает больший эффект, который, в свою очередь, может продолжать компоноваться.

						Каждое приложение имеет «основное волокно».
						Это очень похоже на понятие «основной поток» в том смысле, что это точка, в которой начинается поток управления внутри процесса.
						Традиционно в Cats Effect это основное волокно определяется с помощью IOApp и, в частности, эффектом, возвращаемым методом run:
					</aside>
					<pre><code class="scala"> object Main extends IOApp.Simple {
   val run = IO.println("Hello") >> IO.println("World")
 }</code></pre>
					<aside class="notes">
						В этом примере Main является основным классом.
						Когда он вызывается извне (например, с помощью команды java или с узлом при использовании ScalaJS),
						он запускает основной файбер и работает до тех пор, пока этот файбер не завершится, после чего процесс будет остановлен.

						Когда одно волокно начинает другое волокно, мы обычно говорим, что первое волокно является «родителем» второго.
						Эта связь не является прямо иерархической в том смысле, что родитель может завершиться раньше дочернего,
						не вызывая каких-либо несоответствий.
						Тем не менее, некоторые свойства модели волокон имеют гораздо больше смысла,
						если иметь в виду отношения родитель/потомок.
						Например, файберы всегда могут наблюдать за ошибками и восстанавливаться после них
						(с помощью чего-то вроде handleErrorWith или attempt).
						Это концептуально похоже на try/catch.
						Волокна также могут наблюдать собственную отмену (см. ниже), но они не могут восстановиться после нее,
						то есть не могут продолжать выполнение после отмены.
						Родительские волокна могут инициировать отмену в дочернем элементе (с помощью метода cancel)
						и могут наблюдать окончательный результат этого дочернего элемента (который может быть отменен)
						и могут продолжать выполнение после завершения дочернего элемента.
					</aside>
				</section>

				<section>
					<h3>Asynchronous</h3>
					<p>https://typelevel.org/cats-effect/docs/concepts#asynchronous</p>
					+ в конце страницы:
					<pre><code class="scala">
					In Cats Effect, code containing side-effects should always be wrapped in one of the "special" constructors. In particular:

					Synchronous (returns or throws)
					IO(...) or IO.delay(...)
					IO.blocking(...)
					IO.interruptible(...)
					IO.interruptibleMany(...)
					Asynchronous (invokes a callback)
					IO.async or IO.async_
					</code></pre>
				</section>

				<section>
					<h3>Cancelation</h3>
					<p>https://typelevel.org/cats-effect/docs/concepts#cancelation</p>
				</section>
				<section>
					<h3>Dealing with cancelation</h3>
					<p>https://typelevel.org/cats-effect/docs/tutorial#dealing-with-cancelation</p>
				</section>
				<section>
					<h3>Dealing with cancelation</h3>
					<p>https://typelevel.org/cats-effect/docs/tutorial#dealing-with-cancelation</p>
				</section>




				<section>
					<h3>Http4s</h3>
					<p>???</p>
				</section>

				<section>
					<h3>???</h3>
					<p>???</p>

					<aside class="notes">
						На ближайшем семинаре мы с вами попробуем построить сервер с использованием рассмотренных сегодня библиотек.
					</aside>
				</section>

				<!----------------------------------------------->
				<!-------------------- DRAFT -------------------->
				<!----------------------------------------------->

				<section>
					<p>Напоминаю:
					<ul>
						<li>Страничка курса: <br><a href="https://maxcom.github.io/scala-course-2022/">https://maxcom.github.io/scala-course-2022/</a>
					</ul>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
                                controls: true,
                                progress: true,
                                history: true,
                                center: true,

                                transition: 'slide', // none/fade/slide/convex/concave/zoom

				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
